using System;
using AlgorithmsAndDataStructures.Algorithms.Interfaces;
using AlgorithmsAndDataStructures.ServicesAndHelpers;

namespace AlgorithmsAndDataStructures.Algorithms.SortAndSearch
{
    /// <summary>
    ///     Быстрая сортировка
    /// </summary>
    public class QuickSort : ISortStrategy
    {
        public T[] Sort<T>(T[] array, bool descending = true) where T : IComparable<T>
        {
            var copyArray = new T[array.Length];
            Array.Copy(array, copyArray, array.Length);
            QuickSortIn(copyArray, 0, copyArray.Length - 1);
            return copyArray;
        }

        private void QuickSortIn<T>(T[] array, int beginIndex, int endIndex) where T : IComparable<T>
        {
            //если начальный индекс больше или равен конечному индексу
            //то выходим из метода
            if (beginIndex >= endIndex)
            {
            }
            else
            {
                //иначе продолжаем делить наш массив пополам
                //в меоде Partition происходит самое интересное
                //он возвращает индекс, который делит текущий массив на два подмассива
                //при этом сортировка происходит на месте (то есть прям на текущей ссылки массива)
                var q = Partition(array, beginIndex, endIndex);
                //после деления продолжаем вызывать текущий метод рекурсивно
                //передавая индексы, которые делят массив на два подмассива
                QuickSortIn(array, beginIndex, q - 1);
                QuickSortIn(array, q + 1, endIndex);
            }
        }

        private int Partition<T>(T[] array, int beginIndex, int endIndex) where T : IComparable<T>
        {
            //метод разбиения и является рабочей лошадкой всего способа быстрой сортировки
            //В данной технике сортировки весь массив делится на 4 части (только по индексам, доп память и копирование не требуется, то есть сортировка "НА МЕСТЕ")
            //P -  часть массива называемая опорная, состоит из одного элемента!
            //L (левая часть) -  в данной части находятся элементы которые меньше или равны опрному элементу из части P
            //R (правая часть) -  в данной части находятся элементы которые больше опорного элемента из части P
            //перед этим выбирается индекс, который будет разделять между собой часть L и R (индекс q)
            //U (неизвестная часть) - та часть массива про которую неивестно, элементы ее больше  или меньше опорного элемента
            //при чем надо сказать, что часть U и R никак не отделены друг от друга 
            //(так как в процессе перестановки элементов части U, часть U полностью уйдет и превратится в части L и R)
            //(а значит визуально это будет выглядить так как будто бы часть U превращается в часть R)
            //визуально части будут выглядить следующим образом:
            //
            //  q - элемент по индексу q будет отделять часть L от R (первоначально самый первый элемент во входном подмассиве)
            // -------------
            // |qUUUUUUUU|P| -- первоначально в массиве есть только опорный элемент P, который всегда выбирается с конца входного подмассива
            // -------------    и часть U так как разделение по частям L и R пока не началось
            //
            //    q - элемент по индексу q будет отделять часть L от R
            // -------------
            // |LLqRRUUUU|P| -- постепенно в процессе перестановки элементов из части U они начнут уходить в части L и R
            // -------------
            //
            //
            //      q - элемент по индексу q будет отделять часть L от R
            // -------------
            // |LLLLqRRRR|P| -- в конце все элементы будут разобраны по частям (не обязательно в равном количестве по обоим группам)
            // -------------
            //
            //       q - элемент по индексу q будет отделять часть L от R
            // -------------
            // |LLLL|P|RRRR|-- в конце всего метода поставим опорный элемент в позицию разделителя q 
            // -------------   теперь у нас слева от опорного элемента лежат все элементы, которые меньше или равны опорному
            //                 а справа все элементы, которые больше опорного
            //сначала выбирается индекс q который явялется разделителем текущего массива на две части
            //выбирается он всегда с начала, в процессе перстановки элементов по частям, он будет изменяться
            var q = beginIndex;
            //затем мы пробегаем наш входной подмассив от начала до предпоследнего элемента (не захватывая опорный)
            for (var u = beginIndex; u <= endIndex - 1; u++)
                //если текущий элемент меньше или равен опорному, то
                if (array[u].CompareTo(array[endIndex]) == -1 || array[u].CompareTo(array[endIndex]) == 0)
                {
                    //меняем местами текущий элемент итерации и элемент по индексу q
                    //то есть помещаем текущий элемент в часть L
                    //а часть R это все что останется после пробега по входному подмассиву
                    array.Swap(u, q);
                    q++; //увеличиваем индекс q на единицу
                }

            //в конце поставим наш опорный элемент в позицию разделителя по индексу q
            //теперь у нас есть подмассив в котором слева от опорного элемента стоят все элементы, которые
            //меньше или равны опорному
            //а справа все элементы которые больше опорного
            array.Swap(endIndex, q);
            //возвращаем индекс элемента, который поделил входной подмассив на две части
            return q;
        }
    }
}